.TH "le::ghs" 3 "Wed Jun 15 2022" "GHS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
le::ghs
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBEdge\fP"
.br
.RI "A struct to hold all the communication edge information\&. "
.ti -1c
.RI "class \fBGhsState\fP"
.br
.RI "\fBThe main state machine for the GHS algorithm\fP "
.ti -1c
.RI "class \fBMsg\fP"
.br
.RI "An aggregate type containing all the data to exchange with to/from information\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBagent_t\fP"
.br
.RI "problems for \fBGhsState\fP "
.ti -1c
.RI "typedef unsigned long \fBmetric_t\fP"
.br
.ti -1c
.RI "typedef int \fBlevel_t\fP"
.br
.RI "A 'level' which is an internal item for \fBGhsState\fP to track how many times the MST has merged with another\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBstatus_t\fP { \fBUNKNOWN\fP = 0, \fBMST\fP = 1, \fBMST_PARENT\fP =2, \fBDELETED\fP =-1 }"
.br
.RI "A status enumeration, for the ghs edges\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBis_valid\fP (const \fBagent_t\fP a)"
.br
.ti -1c
.RI "\fBEdge\fP \fBworst_edge\fP ()"
.br
.ti -1c
.RI "bool \fBis_valid\fP (const \fBEdge\fP e)"
.br
.ti -1c
.RI "bool \fBis_valid\fP (const \fBmetric_t\fP m)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBagent_t\fP \fBNO_AGENT\fP =\-1"
.br
.ti -1c
.RI "const \fBmetric_t\fP \fBWORST_METRIC\fP =std::numeric_limits<\fBmetric_t\fP>::max()"
.br
.ti -1c
.RI "const \fBmetric_t\fP \fBMETRIC_NOT_SET\fP =0"
.br
.ti -1c
.RI "const \fBlevel_t\fP \fBLEVEL_START\fP =0"
.br
.RI "All levels start at 0\&. "
.ti -1c
.RI "const unsigned int \fBMAX_MSG_SZ\fP = sizeof(\fBMsg\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
GHS
.PP
The GHS namespace 
.SH "Typedef Documentation"
.PP 
.SS "\fBle::ghs::agent_t\fP"

.PP
problems for \fBGhsState\fP The ghs implementation supports arbitrary integers, as long as they are greater than or equal to zero\&. Use \fBis_valid()\fP to ensure an agent_t will 
.SS "typedef unsigned long \fBle::ghs::metric_t\fP"
A typedef to hold the metrics\&. There's some work to do to make sure the metrics are:
.PP
.IP "\(bu" 2
Symmetric (both peer and root agree on the value)
.IP "\(bu" 2
unique (no two agents have the same metric)
.PP
.PP
However, that is not captured here, and is handled at a 'higher level'\&. See unique_link_metric_to() 
.PP
\fBSee also\fP
.RS 4
DemoComms::unique_link_metric_to() 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBle::ghs::status_t\fP"

.PP
A status enumeration, for the ghs edges\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUNKNOWN \fP\fP
We have not probed this edge for information yet, or have not recieved a reponse\&. 
.TP
\fB\fIMST \fP\fP
We have added this edge as an MST link\&. 
.TP
\fB\fIMST_PARENT \fP\fP
We have added this edge as parent MST link\&. 
.TP
\fB\fIDELETED \fP\fP
We have decided not to further consider this edge, either it was 'bad', or it is already part of our partition\&. 
.SH "Function Documentation"
.PP 
.SS "bool le::ghs::is_valid (const \fBagent_t\fP a)"
Just in case you want an official alias for a>=0\&.
.PP
\fBReturns\fP
.RS 4
true if a>=0 
.PP
false if a==NO_AGENT or is otherwise <0 
.RE
.PP

.SS "bool le::ghs::is_valid (const \fBEdge\fP e)"

.PP
\fBParameters\fP
.RS 4
\fIe\fP an \fBEdge\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true if edge is not \fBworst_edge()\fP and does not have any uninitialized components\&. 
.RE
.PP

.SS "bool le::ghs::is_valid (const \fBmetric_t\fP m)"

.PP
\fBParameters\fP
.RS 4
\fIm\fP a metric_t 
.RE
.PP
\fBReturns\fP
.RS 4
true if the metric_t is not \fCNOT_SET\fP or \fCWORST_METRIC\fP 
.RE
.PP

.SS "\fBEdge\fP le::ghs::worst_edge ()"
Returns the worst possible edge, useful for comparisons in the search for the minimum weight outgoing edge\&. 
.SH "Variable Documentation"
.PP 
.SS "const unsigned int le::ghs::MAX_MSG_SZ = sizeof(\fBMsg\fP)"
For an external class that is interested in allocating static storage to queue a set of \fBMsg\fP s, this is the maximum size of the \fBMsg\fP class\&. 
.SS "const \fBmetric_t\fP le::ghs::METRIC_NOT_SET =0"
This is set to zero because metrics are usually zero initialized by default, and we do not want to have a bunch of zeros floating around in our search 
.SS "const \fBagent_t\fP le::ghs::NO_AGENT =\-1"
This means not set 
.SS "const \fBmetric_t\fP le::ghs::WORST_METRIC =std::numeric_limits<\fBmetric_t\fP>::max()"
This is the 'worst' metric possible, defined simply as the maximum value reachable\&.
.PP
We all need to agree on the worst metric, since we're all comparing against this to determine if we found a minimum weight outgoing edge\&. See mwoe()
.PP
\fBSee also\fP
.RS 4
\fBGhsState::mwoe()\fP for how it is used 
.PP
DemoComms::unique_link_metric_to() for why it is a size_t 
.PP
DemoComms::little_iperf() 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for GHS from the source code\&.
