.TH "le::ghs::GhsState< NUM_AGENTS, MSG_Q_SIZE >" 3 "Wed Jun 15 2022" "GHS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
le::ghs::GhsState< NUM_AGENTS, MSG_Q_SIZE > \- \fBThe main state machine for the GHS algorithm\fP  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ghs\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGhsState\fP (\fBagent_t\fP my_id, \fBEdge\fP *edges, size_t num_edges)"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBstart_round\fP (\fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > &outgoing_msgs, size_t &)"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBprocess\fP (const \fBMsg\fP &msg, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > &outgoing_buffer, size_t &sz)"
.br
.ti -1c
.RI "bool \fBis_converged\fP () const"
.br
.ti -1c
.RI "size_t \fBget_n_peers\fP () const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBget_edge\fP (const \fBagent_t\fP &to, \fBEdge\fP &out) const"
.br
.ti -1c
.RI "bool \fBhas_edge\fP (const \fBagent_t\fP to) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBget_edge_status\fP (const \fBagent_t\fP &to, \fBstatus_t\fP &out) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBget_edge_metric\fP (const \fBagent_t\fP &to, \fBmetric_t\fP &m) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBis_waiting_for\fP (const \fBagent_t\fP &who, bool &out_waiting_for)"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBis_response_required\fP (const \fBagent_t\fP &who, bool &response_required)"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBget_response_prompt\fP (const \fBagent_t\fP &who, \fBmsg::InPartPayload\fP &m)"
.br
.ti -1c
.RI "\fBagent_t\fP \fBget_id\fP () const"
.br
.ti -1c
.RI "\fBagent_t\fP \fBget_parent_id\fP () const"
.br
.ti -1c
.RI "\fBagent_t\fP \fBget_leader_id\fP () const"
.br
.ti -1c
.RI "\fBlevel_t\fP \fBget_level\fP () const"
.br
.ti -1c
.RI "size_t \fBwaiting_count\fP () const"
.br
.ti -1c
.RI "size_t \fBdelayed_count\fP () const"
.br
.ti -1c
.RI "\fBEdge\fP \fBmwoe\fP () const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBchecked_index_of\fP (const \fBagent_t\fP &, size_t &) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBmst_broadcast\fP (const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > &buf, size_t &) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBmst_convergecast\fP (const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > &buf, size_t &) const"
.br
.ti -1c
.RI "\fBle::Errno\fP \fBtypecast\fP (const \fBstatus_t\fP status, const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > &buf, size_t &) const"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE>
.br
class le::ghs::GhsState< NUM_AGENTS, MSG_Q_SIZE >"
\fBThe main state machine for the GHS algorithm\fP 

\fBGhsState\fP is the message-driven state machine that executes the GHS algorithm\&. It receives incoming messages from a communication layer, and returns the next batch of messages to send\&. When completed, \fBis_converged()\fP will return true\&.
.PP
You are responsible for describing the communication graph by calling, probably, set_edge() and then starting the algorithm by calling \fBstart_round()\fP on at least one node (the root), but most likely just call it on all nodes, which will generate the first set of messages to send\&.
.PP
Then, as response messages come in from other nodes, just feed them into \fBprocess()\fP until \fBis_converged()\fP is true\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> GhsState::GhsState (\fBagent_t\fP my_id, \fBEdge\fP * edges, size_t num_edges)"
Initializes the state of the GHS algorithm for this particular node\&.
.PP
Requires a agent_t to represent the node id, which will be used in all incoming and outgoing mesasages (unique among all agents)\&.
.PP
Requires a list of \fBle::ghs::Edge\fP structures that represent the communication links to other agents that will not be modified during execution\&.
.PP
The edge list may contain any number of edges (up to NUM_AGENTS)\&. This class will ignore (not copy in) any edge that:
.PP
.IP "\(bu" 2
Is not rooted on this node (\fBEdge\&.root\fP != my_id)
.IP "\(bu" 2
Is directed to this node (\fBEdge\&.peer\fP == my_id)
.IP "\(bu" 2
Has either peer or root set to \fBle::ghs::NO_AGENT\fP
.IP "\(bu" 2
Has metric_val set to that of \fBworst_edge()\fP
.IP "\(bu" 2
otherwise does not pass \fBis_valid()\fP
.PP
.PP
The following conditions will produce undefined behavior:
.PP
.IP "\(bu" 2
Passing in two or more edges with the same peer and root
.PP
.PP
After the construction, you can verify the number of copied edges with \fBget_n_peers()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fImy_id\fP of type agent_t that tells the class which edges to consider 
.br
\fIedges\fP a set of \fBle::ghs::Edge\fP structures, which are filtered and stored internally to determine message destinations\&. 
.br
\fInum_edges\fP the length of the edge set 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::checked_index_of (const \fBagent_t\fP & who, size_t & idx) const"
A much-called function that returns the index of the given agent\&. The index corresponds to a number 0 to N-1 for N agents, such that all data about that agent can be stored in consecutive memory\&. This is not a hash function! It simply searches as an O(n) operation, the memory for the matching ID\&.
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if the index was found 
.PP
\fBle::Errno\fP NO_SUCH_PEER if not 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if you requsted index to this agent 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> size_t GhsState::delayed_count () const"
Returns the number of agents from which we have received an IN_PART message that we have not responded to\&.
.PP
\fBReturns\fP
.RS 4
size_t 
.RE
.PP
\fBSee also\fP
.RS 4
set_response_required() 
.PP
\fBmsg::InPartPayload\fP 
.PP
\fBMsg\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::get_edge (const \fBagent_t\fP & to, \fBEdge\fP & out) const"
Populates the given edge with any stored edge that connects this agent to another agent\&. If we are unaware of that agent or do not have an edge, return error code\&.
.PP
\fBParameters\fP
.RS 4
\fIto\fP an agent_t to look up 
.br
\fIout\fP and \fBEdge\fP to populate as an out parameter 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id 
.PP
\fBle::Errno\fP NO_SUCH_PEER if edge cannot be found 
.PP
\fBle::Errno\fP OK if successful 
.RE
.PP
\fBSee also\fP
.RS 4
\fBhas_edge()\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::get_edge_metric (const \fBagent_t\fP & to, \fBmetric_t\fP & m) const"
Returns the edge metric to the given agent\&.
.PP
\fBParameters\fP
.RS 4
\fIto\fP agent_t identifier 
.br
\fIm\fP the metric_t that is populated if the function is successful 
.RE
.PP
\fBReturns\fP
.RS 4
OK if successful 
.PP
\fBle::Errno\fP NO_SUCH_PEER if we cannot find the given agent id 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::get_edge_status (const \fBagent_t\fP & to, \fBstatus_t\fP & out) const"
Returns the edge status to the given agent\&.
.PP
\fBParameters\fP
.RS 4
\fIto\fP agent_t identifier 
.br
\fIout\fP the status_t that is populated if the function is successful 
.RE
.PP
\fBReturns\fP
.RS 4
OK if successful 
.PP
\fBle::Errno\fP NO_SUCH_PEER if we cannot find the given agent id 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBagent_t\fP GhsState::get_id () const"
Returns whatever was set (or initialized) as the agent_t for this state machine
.PP
Never fails to return
.PP
\fBReturns\fP
.RS 4
agent_t for this class's id\&. 
.br
 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBagent_t\fP GhsState::get_leader_id () const"
Returns whatever I believe my leader is 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBlevel_t\fP GhsState::get_level () const"
Returns whatever I believe this partition's level is 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> size_t \fBle::ghs::GhsState\fP< NUM_AGENTS, MSG_Q_SIZE >::get_n_peers () const\fC [inline]\fP"
Returns the number of peers, which is a counter that is incremented every time you add_edge_to(id) (or variant), with a new id\&. 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBagent_t\fP GhsState::get_parent_id () const"
Returns whatever I believe my parent is 
.PP
\fBReturns\fP
.RS 4
agent_t corresponding to the parent id\&. Could be self! 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::get_response_prompt (const \fBagent_t\fP & who, \fBmsg::InPartPayload\fP & m)"
Returns the message that triggered a delay in response\&.
.PP
\fBParameters\fP
.RS 4
\fIagent_t\fP who sent the message 
.br
\fIInPartPayload\fP the outgoing payload of the message that we cannot respond to yet 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if successful 
.PP
\fBle::Errno\fP NO_SUCH_PEER if we cannot find the given agent id 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> bool GhsState::has_edge (const \fBagent_t\fP to) const"
Returns true if any of the following will work:
.PP
.PP
.nf
get_edge()
set_edge_status()
get_edge_status()
set_edge_metric()
get_edge_metric()
set_response_required()
is_response_required()
set_response_prompt() 
get_response_prompt()
.fi
.PP
.PP
If it returns false, all of them will fail by returning something other than \fBle::Errno\fP OK\&. 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> bool GhsState::is_converged () const"

.PP
\fBReturns\fP
.RS 4
true if the state machine believes that a global MST has converged 
.PP
false otherwise 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::is_response_required (const \fBagent_t\fP & who, bool & response_required)"
returns the response-delayed status for the given agent\&.
.PP
\fBParameters\fP
.RS 4
\fIagent_t\fP who 
.br
\fIbool\fP waiting to send (true) or not waiting (false) 
.RE
.PP
\fBReturns\fP
.RS 4
OK if successful and \fCwaiting_for\fP is a valid return 
.PP
\fBle::Errno\fP NO_SUCH_PEER if we cannot find the given agent id and \fCwaiting_for\fP may have any value 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id and \fCwaiting_for\fP may have any value 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::is_waiting_for (const \fBagent_t\fP & who, bool & out_waiting_for)"
returns the waiting status for the given agent\&.
.PP
\fBParameters\fP
.RS 4
\fIagent_t\fP who 
.br
\fIbool\fP waiting for response (true) or not waiting for response (false) 
.RE
.PP
\fBReturns\fP
.RS 4
OK if successful and \fCwaiting_for\fP is a valid return 
.PP
\fBle::Errno\fP NO_SUCH_PEER if we cannot find the given agent id and \fCwaiting_for\fP may have any value 
.PP
\fBle::Errno\fP IMPL_REQ_PEER_MY_ID if edge has peer==my_id and \fCwaiting_for\fP may have any value 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::mst_broadcast (const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > & buf, size_t &) const"
Sends messages to MST child links only\&. There are very good reasons for using MST links even for non-ghs messages, so this is public\&.
.PP
For example, this ensures each node only receives one copy, even if it is a 'bottleneck' leading towards many agents\&.
.PP
Functionally equivalent to:
.PP
.PP
.nf
Mst m;
StaticQueue buf;
size_t qsz;
return mst_typecast(MST, m\&.type, m\&.data, buf, qsz);
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fImsg::Type\fP denoting what type of message to send 
.br
\fI\fBmsg::Data\fP\fP denoting what message data to broadcast 
.br
\fIStaticQueue\fP in which to queue the outgoing messages 
.br
\fIsize_t\fP denoting how many messages were enqueued \fIonly\fP if OK is returned\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if everything went well 
.PP
CAST_INVALID_EDGE if we found an edge without us as root 
.RE
.PP
\fBSee also\fP
.RS 4
set_edge_status() 
.PP
mst_typecast() 
.PP
\fBmst_convergecast()\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::mst_convergecast (const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > & buf, size_t &) const"
The opposite of mst_broadcast, will send messages 'UP' the MST to the root\&.
.PP
useful for conducting 'reduce' operations on an MST, assuming it is combined with a useful data reduction strategy\&.
.PP
In GHS, the reduction strategy is to compare \fBmsg::SrchRetPayload\fP from all incoming MST links, and pass the minimum weight edge up to the parent\&.
.PP
Is actually implemented with a search across all edges for one of type MST and with peer matching our parent id\&.
.PP
\fBParameters\fP
.RS 4
\fImsg::Type\fP denoting what type of message to send 
.br
\fI\fBmsg::Data\fP\fP denoting what message data to broadcast 
.br
\fIStaticQueue\fP in which to queue the outgoing messages 
.br
\fIsize_t\fP denoting how many messages were enqueued \fIonly\fP if OK is returned\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if everything went well 
.PP
CAST_INVALID_EDGE if we found an edge without us as root 
.RE
.PP
\fBSee also\fP
.RS 4
set_edge_status() 
.PP
mst_typecast() 
.PP
\fBmst_convergecast()\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBEdge\fP GhsState::mwoe () const"
Returns the current minimum weight outgoing edge (MWOE)\&.
.PP
This is the edge we would add to our partition if you forced us to chose from our minimum spanning tree rooted at ourself\&. To find the global MWOE, these are passed UP the MST using \fBmst_convergecast()\fP, with a \fBmsg::SrchRetPayload\fP\&. At each node, the \fBmsg::SrchRetPayload\fP is compared to our \fBmwoe()\fP to determine the actual best edge all the way up to the root of the MST for this partition\&. After that, a \fBmsg::JoinUsPayload\fP is sent back from the root using \fBmst_broadcast()\fP to trigger the process of adding that edge to the MST
.PP
\fBReturns\fP
.RS 4
size_t 
.RE
.PP
\fBSee also\fP
.RS 4
set_response_required() 
.PP
\fBmsg::InPartPayload\fP 
.PP
\fBMsg\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::process (const \fBMsg\fP & msg, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > & outgoing_buffer, size_t & sz)"
The main class entry point\&. It will puplate the outgoing_buffer with message that should be sent as a response to the passed-in message\&. You can execute the entire algorithm simply by calling \fBprocess()\fP with a \fBmsg::SrchPayload\fP message properly constructed (but use \fBstart_round()\fP for this), then feeding in all the response messages\&.
.PP
\fBParameters\fP
.RS 4
\fI\fBMsg\fP\fP to process 
.br
\fIStaticQueue\fP into which to push the response messages 
.br
\fIsz\fP the size_t that will be set to the number of messages added to outgoing_buffer on success, or left unset otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBMsg\fP 
.PP
\fBle::Errno\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::start_round (\fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > & outgoing_msgs, size_t &)"
\fBONLY IF\fP this node is the root of an MST (even an MST with only itself as a member) \fBTHEN\fP this function will enqueue the first set of messages to send to all peers, and set up the internal state of the algorithm to be ready to process the responses\&.
.PP
In short it:
.IP "\(bu" 2
checks to make sure we're not already in a search phase, exiting with error if we are\&.
.IP "\(bu" 2
resets the MWOE to a default value
.IP "\(bu" 2
creates a \fBmsg::SrchPayload\fP and calls \fBmst_broadcast()\fP
.PP
.PP
Calling \fBstart_round()\fP while in the middle of a round will essentially lose all state, such that incomign messages that are not a response to \fIthese outgoing messages\fP will likely cause errors\&.
.PP
However, no edge statuses are changed, so executing start_round is safe if you already know of some MST links and have edited them in, or have somehow terminated a round and want to resume it\&.
.PP
\fBParameters\fP
.RS 4
\fIStaticQeueue\fP in which to enque outgoing messages 
.br
\fIsize_t\fP the number of messages enque'd 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if successful 
.PP
\fBle::Errno\fP SRCH_STILL_WAITING if \fBwaiting_count()\fP is not zero
.RE
.PP
Queue up the start of the round 
.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> \fBle::Errno\fP GhsState::typecast (const \fBstatus_t\fP status, const \fBmsg::Type\fP, const \fBmsg::Data\fP &, \fBStaticQueue\fP< \fBMsg\fP, MSG_Q_SIZE > & buf, size_t &) const"
Filters edges by \fCmsgtype\fP, and sends outgoing message along those that match\&.
.PP
\fBParameters\fP
.RS 4
\fIstatus_t\fP the edge status along which to send messages\&. 
.br
\fImsg::Type\fP denoting what type of message to send 
.br
\fI\fBmsg::Data\fP\fP denoting what message data to broadcast 
.br
\fIStaticQueue\fP in which to queue the outgoing messages 
.br
\fIsize_t\fP denoting how many messages were enqueued \fIonly\fP if OK is returned\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBle::Errno\fP OK if everything went well 
.PP
CAST_INVALID_EDGE if we found an edge without us as root 
.RE
.PP
\fBSee also\fP
.RS 4
set_edge_status() 
.PP
mst_typecast() 
.PP
\fBmst_convergecast()\fP 
.RE
.PP

.SS "template<std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE> size_t GhsState::waiting_count () const"
Returns the number of agents to which we have already sent IN_PART messages, but from which we have not yet received ACK_PART or NACK_PART messages\&.
.PP
\fBReturns\fP
.RS 4
size_t 
.RE
.PP
\fBSee also\fP
.RS 4
set_waiting_for() 
.PP
\fBmsg::InPartPayload\fP 
.PP
\fBMsg\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for GHS from the source code\&.
