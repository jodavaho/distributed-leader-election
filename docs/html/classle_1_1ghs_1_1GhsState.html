<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHS: le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHS
   </div>
   <div id="projectbrief">Leader Election Based on GHS Minimum Spanning Tree</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacele.html">le</a></li><li class="navelem"><a class="el" href="namespacele_1_1ghs.html">ghs</a></li><li class="navelem"><a class="el" href="classle_1_1ghs_1_1GhsState.html">GhsState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classle_1_1ghs_1_1GhsState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b>The main state machine for the GHS algorithm</b>  
 <a href="classle_1_1ghs_1_1GhsState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ghs_8h_source.html">ghs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63e8cefb71f2d7c233f77402e9b2505a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a63e8cefb71f2d7c233f77402e9b2505a">GhsState</a> (<a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> my_id)</td></tr>
<tr class="separator:a63e8cefb71f2d7c233f77402e9b2505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d8fd7601b228107b8c91d087cca5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge</a> (const <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;e)</td></tr>
<tr class="separator:aea4d8fd7601b228107b8c91d087cca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba808501a79436c12c7a78e0c13254c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#aba808501a79436c12c7a78e0c13254c6">add_edge</a> (const <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;e)</td></tr>
<tr class="separator:aba808501a79436c12c7a78e0c13254c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e70d209da5cbc4f76cef068ee2afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a669e70d209da5cbc4f76cef068ee2afd">add_edge_to</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to)</td></tr>
<tr class="separator:a669e70d209da5cbc4f76cef068ee2afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d9729e0a7ec8ec63e12c261c63af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a491d9729e0a7ec8ec63e12c261c63af6">get_edge</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;out) const</td></tr>
<tr class="separator:a491d9729e0a7ec8ec63e12c261c63af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32752d80f78b09c368236e864de84e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a32752d80f78b09c368236e864de84e0d">has_edge</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to) const</td></tr>
<tr class="separator:a32752d80f78b09c368236e864de84e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9060b49a13e52c70f195059c772037a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;status)</td></tr>
<tr class="separator:a9060b49a13e52c70f195059c772037a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dfe0a489d1b84d87772c5db4382d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a08dfe0a489d1b84d87772c5db4382d8f">get_edge_status</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;out) const</td></tr>
<tr class="separator:a08dfe0a489d1b84d87772c5db4382d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbf1bd3e39538b1bd36e0b5436c8f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a1fbf1bd3e39538b1bd36e0b5436c8f96">set_edge_metric</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, const <a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> m)</td></tr>
<tr class="separator:a1fbf1bd3e39538b1bd36e0b5436c8f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cb3901a7cee8c9fad5e39aa5f310e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ab6cb3901a7cee8c9fad5e39aa5f310e8">get_edge_metric</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> &amp;m) const</td></tr>
<tr class="separator:ab6cb3901a7cee8c9fad5e39aa5f310e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad468fa0b565af04eccebf400bf48d18a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ad468fa0b565af04eccebf400bf48d18a">set_leader_id</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;leader)</td></tr>
<tr class="separator:ad468fa0b565af04eccebf400bf48d18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89293e324b9b4b7f1b4f7f1a276ebd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ab89293e324b9b4b7f1b4f7f1a276ebd8">set_level</a> (const <a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a> &amp;level)</td></tr>
<tr class="separator:ab89293e324b9b4b7f1b4f7f1a276ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdffbfd844f9725278968aedef953c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#acdffbfd844f9725278968aedef953c71">set_waiting_for</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, const bool waiting_for)</td></tr>
<tr class="separator:acdffbfd844f9725278968aedef953c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2dd6a4348cf7b0081bf349188f6abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a7d2dd6a4348cf7b0081bf349188f6abd">is_waiting_for</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, bool &amp;out_waiting_for)</td></tr>
<tr class="separator:a7d2dd6a4348cf7b0081bf349188f6abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d346bd8cc18b48b7bc02396aba5387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a25d346bd8cc18b48b7bc02396aba5387">set_response_required</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, const bool response_required)</td></tr>
<tr class="separator:a25d346bd8cc18b48b7bc02396aba5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7429a609856ffa154ad57e06fd9ac718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a7429a609856ffa154ad57e06fd9ac718">is_response_required</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, bool &amp;response_required)</td></tr>
<tr class="separator:a7429a609856ffa154ad57e06fd9ac718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614b988eb7e1e715fd9ac8c3335c321b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a614b988eb7e1e715fd9ac8c3335c321b">set_response_prompt</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, const <a class="el" href="structle_1_1ghs_1_1InPartPayload.html">InPartPayload</a> &amp;m)</td></tr>
<tr class="separator:a614b988eb7e1e715fd9ac8c3335c321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a247c6505cff0a2c585da498278fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#af00a247c6505cff0a2c585da498278fc">get_response_prompt</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, <a class="el" href="structle_1_1ghs_1_1InPartPayload.html">InPartPayload</a> &amp;m)</td></tr>
<tr class="separator:af00a247c6505cff0a2c585da498278fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f35fee46691587eb4d6f351b0e75ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a4f35fee46691587eb4d6f351b0e75ff8">get_id</a> () const</td></tr>
<tr class="separator:a4f35fee46691587eb4d6f351b0e75ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba914bec431efab91efc47c7f105057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#abba914bec431efab91efc47c7f105057">get_parent_id</a> () const</td></tr>
<tr class="separator:abba914bec431efab91efc47c7f105057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325badddc6fbbb2e1120cb939af2e806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a325badddc6fbbb2e1120cb939af2e806">set_parent_id</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;id)</td></tr>
<tr class="separator:a325badddc6fbbb2e1120cb939af2e806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789e0899e91d62a6d2cc11a66833d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a6789e0899e91d62a6d2cc11a66833d89">get_leader_id</a> () const</td></tr>
<tr class="separator:a6789e0899e91d62a6d2cc11a66833d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34be79320fdff6ee68650d582fc7756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ac34be79320fdff6ee68650d582fc7756">get_level</a> () const</td></tr>
<tr class="separator:ac34be79320fdff6ee68650d582fc7756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a22ed8e6d3e432da497631a99bd414"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a30a22ed8e6d3e432da497631a99bd414">waiting_count</a> () const</td></tr>
<tr class="separator:a30a22ed8e6d3e432da497631a99bd414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb95007147563e87a19aaca69531ce2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#aabb95007147563e87a19aaca69531ce2">delayed_count</a> () const</td></tr>
<tr class="separator:aabb95007147563e87a19aaca69531ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692b1f38078dd2f3a39b36f61fd5ef54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a692b1f38078dd2f3a39b36f61fd5ef54">mwoe</a> () const</td></tr>
<tr class="separator:a692b1f38078dd2f3a39b36f61fd5ef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b67adf0443e2bd7994881a16a292afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a3b67adf0443e2bd7994881a16a292afc">mst_broadcast</a> (const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:a3b67adf0443e2bd7994881a16a292afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68361919ac2145344adf1d4d92f3d4f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a68361919ac2145344adf1d4d92f3d4f4">mst_convergecast</a> (const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:a68361919ac2145344adf1d4d92f3d4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c221ee7a83dbd0ab71291f52143f393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a4c221ee7a83dbd0ab71291f52143f393">typecast</a> (const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> status, const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:a4c221ee7a83dbd0ab71291f52143f393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817fb9ac310ad6d8cd51bb5094fa7f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a817fb9ac310ad6d8cd51bb5094fa7f3d">start_round</a> (<a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;outgoing_msgs, size_t &amp;)</td></tr>
<tr class="separator:a817fb9ac310ad6d8cd51bb5094fa7f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389f079174e451d1e53b49ca87e33db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9389f079174e451d1e53b49ca87e33db">process</a> (const <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a> &amp;msg, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;outgoing_buffer, size_t &amp;sz)</td></tr>
<tr class="separator:a9389f079174e451d1e53b49ca87e33db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3eb11d5455ae117d917555a429842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a99d3eb11d5455ae117d917555a429842">reset</a> ()</td></tr>
<tr class="separator:a99d3eb11d5455ae117d917555a429842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6f3f76c3e48e65e00e2887a9592d9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged</a> () const</td></tr>
<tr class="separator:acf6f3f76c3e48e65e00e2887a9592d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab8531afa092db6a5958a6987369bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a85ab8531afa092db6a5958a6987369bd">get_n_peers</a> () const</td></tr>
<tr class="separator:a85ab8531afa092db6a5958a6987369bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf2e1ef73dd4b334fe5f13746a57416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#abaf2e1ef73dd4b334fe5f13746a57416">checked_index_of</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;, size_t &amp;) const</td></tr>
<tr class="separator:abaf2e1ef73dd4b334fe5f13746a57416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt;<br />
class le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt;</h3>

<p><b>The main state machine for the GHS algorithm</b> </p>
<p><a class="el" href="classle_1_1ghs_1_1GhsState.html" title="The main state machine for the GHS algorithm">GhsState</a> is the message-driven state machine that executes the GHS algorithm. It receives incoming messages from a communication layer, and returns the next batch of messages to send. When completed, <a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged()</a> will return true.</p>
<p>You are responsible for describing the communication graph by calling, probably, <a class="el" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge()</a> and then starting the algorithm by calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#a817fb9ac310ad6d8cd51bb5094fa7f3d">start_round()</a> on at least one node (the root), but most likely just call it on all nodes, which will generate the first set of messages to send.</p>
<p>Then, as response messages come in from other nodes, just feed them into <a class="el" href="classle_1_1ghs_1_1GhsState.html#a9389f079174e451d1e53b49ca87e33db">process()</a> until <a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged()</a> is true. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63e8cefb71f2d7c233f77402e9b2505a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e8cefb71f2d7c233f77402e9b2505a">&#9670;&nbsp;</a></span>GhsState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GhsState::GhsState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td>
          <td class="paramname"><em>my_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the state of the GHS algorithm for this particular node.</p>
<p>Requires a agent_t to represent the node id, which will be used in all incoming and outgoing mesasages (unique among all agents).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_id</td><td>of type agent_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba808501a79436c12c7a78e0c13254c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba808501a79436c12c7a78e0c13254c6">&#9670;&nbsp;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> <a class="el" href="classle_1_1ghs_1_1GhsState.html">le::ghs::GhsState</a>&lt; NUM_AGENTS, MSG_Q_SIZE &gt;::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does nothing more than call set_edge(e) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge()</a> </dd></dl>

</div>
</div>
<a id="a669e70d209da5cbc4f76cef068ee2afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669e70d209da5cbc4f76cef068ee2afd">&#9670;&nbsp;</a></span>add_edge_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::add_edge_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a default <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to the given agent.</p>
<p>This is identical to doing the following:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> to;</div>
<div class="line">Edge e; <span class="comment">// Note defaults are sane per Edge()</span></div>
<div class="line">e.peer = to;</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge</a>(e);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>of type agent_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode similar to <a class="el" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a32752d80f78b09c368236e864de84e0d">has_edge()</a> </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge()</a> </dd></dl>

</div>
</div>
<a id="abaf2e1ef73dd4b334fe5f13746a57416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf2e1ef73dd4b334fe5f13746a57416">&#9670;&nbsp;</a></span>checked_index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::checked_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A much-called function that returns the index of the given agent. The index corresponds to a number 0 to N-1 for N agents, such that all data about that agent can be stored in consecutive memory. This is not a hash function! It simply searches as an O(n) operation, the memory for the matching ID.</p>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if the index was found </dd>
<dd>
Retcode NO_SUCH_PEER if not </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if you requsted index to this agent </dd></dl>

</div>
</div>
<a id="aabb95007147563e87a19aaca69531ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb95007147563e87a19aaca69531ce2">&#9670;&nbsp;</a></span>delayed_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t GhsState::delayed_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of agents from which we have received an IN_PART message that we have not responded to.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a25d346bd8cc18b48b7bc02396aba5387">set_response_required()</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">InPartPayload</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<a id="a491d9729e0a7ec8ec63e12c261c63af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491d9729e0a7ec8ec63e12c261c63af6">&#9670;&nbsp;</a></span>get_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates the given edge with any stored edge that connects this agent to another agent. If we are unaware of that agent or do not have an edge, return error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>an agent_t to look up </td></tr>
    <tr><td class="paramname">out</td><td>and <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to populate as an out parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd>
<dd>
Retcode NO_SUCH_PEER if edge cannot be found </dd>
<dd>
Retcode OK if successful </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a32752d80f78b09c368236e864de84e0d">has_edge()</a> </dd></dl>

</div>
</div>
<a id="ab6cb3901a7cee8c9fad5e39aa5f310e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cb3901a7cee8c9fad5e39aa5f310e8">&#9670;&nbsp;</a></span>get_edge_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::get_edge_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the edge metric to the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">m</td><td>the metric_t that is populated if the function is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a08dfe0a489d1b84d87772c5db4382d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dfe0a489d1b84d87772c5db4382d8f">&#9670;&nbsp;</a></span>get_edge_status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::get_edge_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the edge status to the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">out</td><td>the status_t that is populated if the function is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a4f35fee46691587eb4d6f351b0e75ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f35fee46691587eb4d6f351b0e75ff8">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever was set (or initialized) as the agent_t for this state machine</p>
<p>Never fails to return</p>
<dl class="section return"><dt>Returns</dt><dd>agent_t for this class's id. <br  />
 </dd></dl>

</div>
</div>
<a id="a6789e0899e91d62a6d2cc11a66833d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789e0899e91d62a6d2cc11a66833d89">&#9670;&nbsp;</a></span>get_leader_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_leader_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe my leader is </p>

</div>
</div>
<a id="ac34be79320fdff6ee68650d582fc7756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34be79320fdff6ee68650d582fc7756">&#9670;&nbsp;</a></span>get_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a> GhsState::get_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe this partition's level is </p>

</div>
</div>
<a id="a85ab8531afa092db6a5958a6987369bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ab8531afa092db6a5958a6987369bd">&#9670;&nbsp;</a></span>get_n_peers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classle_1_1ghs_1_1GhsState.html">le::ghs::GhsState</a>&lt; NUM_AGENTS, MSG_Q_SIZE &gt;::get_n_peers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of peers, which is a counter that is incremented every time you add_edge_to(id) (or variant), with a new id. </p>

</div>
</div>
<a id="abba914bec431efab91efc47c7f105057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba914bec431efab91efc47c7f105057">&#9670;&nbsp;</a></span>get_parent_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_parent_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe my parent is </p><dl class="section return"><dt>Returns</dt><dd>agent_t corresponding to the parent id. Could be self! </dd></dl>

</div>
</div>
<a id="af00a247c6505cff0a2c585da498278fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a247c6505cff0a2c585da498278fc">&#9670;&nbsp;</a></span>get_response_prompt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::get_response_prompt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structle_1_1ghs_1_1InPartPayload.html">InPartPayload</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the message that triggered a delay in response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who sent the message </td></tr>
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">InPartPayload</a></td><td>the outgoing payload of the message that we cannot respond to yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a32752d80f78b09c368236e864de84e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32752d80f78b09c368236e864de84e0d">&#9670;&nbsp;</a></span>has_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GhsState::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any of the following will work:</p>
<div class="fragment"><div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a491d9729e0a7ec8ec63e12c261c63af6">get_edge</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a08dfe0a489d1b84d87772c5db4382d8f">get_edge_status</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a1fbf1bd3e39538b1bd36e0b5436c8f96">set_edge_metric</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#ab6cb3901a7cee8c9fad5e39aa5f310e8">get_edge_metric</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a25d346bd8cc18b48b7bc02396aba5387">set_response_required</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a7429a609856ffa154ad57e06fd9ac718">is_response_required</a>()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a614b988eb7e1e715fd9ac8c3335c321b">set_response_prompt</a>() </div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#af00a247c6505cff0a2c585da498278fc">get_response_prompt</a>()</div>
</div><!-- fragment --><p>If it returns false, all of them will fail by returning something other than Retcode OK. </p>

</div>
</div>
<a id="acf6f3f76c3e48e65e00e2887a9592d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6f3f76c3e48e65e00e2887a9592d9f">&#9670;&nbsp;</a></span>is_converged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GhsState::is_converged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the state machine believes that a global MST has converged </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a7429a609856ffa154ad57e06fd9ac718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7429a609856ffa154ad57e06fd9ac718">&#9670;&nbsp;</a></span>is_response_required()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::is_response_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>response_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the response-delayed status for the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting to send (true) or not waiting (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful and <code>waiting_for</code> is a valid return </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id and <code>waiting_for</code> may have any value </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id and <code>waiting_for</code> may have any value </dd></dl>

</div>
</div>
<a id="a7d2dd6a4348cf7b0081bf349188f6abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2dd6a4348cf7b0081bf349188f6abd">&#9670;&nbsp;</a></span>is_waiting_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::is_waiting_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>out_waiting_for</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the waiting status for the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting for response (true) or not waiting for response (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful and <code>waiting_for</code> is a valid return </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id and <code>waiting_for</code> may have any value </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id and <code>waiting_for</code> may have any value </dd></dl>

</div>
</div>
<a id="a3b67adf0443e2bd7994881a16a292afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b67adf0443e2bd7994881a16a292afc">&#9670;&nbsp;</a></span>mst_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::mst_broadcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends messages to MST child links only. There are very good reasons for using MST links even for non-ghs messages, so this is public.</p>
<p>For example, this ensures each node only receives one copy, even if it is a "bottleneck" leading towards many agents.</p>
<p>Functionally equivalent to:</p>
<div class="fragment"><div class="line">Mst m;</div>
<div class="line">StaticQueue buf;</div>
<div class="line"><span class="keywordtype">size_t</span> qsz;</div>
<div class="line"><span class="keywordflow">return</span> mst_typecast(<a class="code" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b">MST</a>, m.type, m.data, buf, qsz);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5" title="Stores what type of Msg this is.">Msg::Type</a></td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html" title="A union of all possible payloads.">Msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status()</a> </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a68361919ac2145344adf1d4d92f3d4f4">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a68361919ac2145344adf1d4d92f3d4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68361919ac2145344adf1d4d92f3d4f4">&#9670;&nbsp;</a></span>mst_convergecast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::mst_convergecast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The opposite of mst_broadcast, will send messages "UP" the MST to the root.</p>
<p>useful for conducting "reduce" operations on an MST, assuming it is combined with a useful data reduction strategy.</p>
<p>In GHS, the reduction strategy is to compare <a class="el" href="structle_1_1ghs_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">SrchRetPayload</a> from all incoming MST links, and pass the minimum weight edge up to the parent.</p>
<p>Is actually implemented with a search across all edges for one of type MST and with peer matching our parent id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5" title="Stores what type of Msg this is.">Msg::Type</a></td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html" title="A union of all possible payloads.">Msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status()</a> </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a68361919ac2145344adf1d4d92f3d4f4">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a692b1f38078dd2f3a39b36f61fd5ef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b1f38078dd2f3a39b36f61fd5ef54">&#9670;&nbsp;</a></span>mwoe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> GhsState::mwoe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current minimum weight outgoing edge (MWOE).</p>
<p>This is the edge we would add to our partition if you forced us to chose from our minimum spanning tree rooted at ourself. To find the global MWOE, these are passed UP the MST using <a class="el" href="classle_1_1ghs_1_1GhsState.html#a68361919ac2145344adf1d4d92f3d4f4">mst_convergecast()</a>, with a <a class="el" href="structle_1_1ghs_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">SrchRetPayload</a>. At each node, the <a class="el" href="structle_1_1ghs_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">SrchRetPayload</a> is compared to our <a class="el" href="classle_1_1ghs_1_1GhsState.html#a692b1f38078dd2f3a39b36f61fd5ef54">mwoe()</a> to determine the actual best edge all the way up to the root of the MST for this partition. After that, a <a class="el" href="structle_1_1ghs_1_1JoinUsPayload.html" title="Msgs to merge /absorb two partitions across a given edge.">JoinUsPayload</a> is sent back from the root using <a class="el" href="classle_1_1ghs_1_1GhsState.html#a3b67adf0443e2bd7994881a16a292afc">mst_broadcast()</a> to trigger the process of adding that edge to the MST</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a25d346bd8cc18b48b7bc02396aba5387">set_response_required()</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">InPartPayload</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<a id="a9389f079174e451d1e53b49ca87e33db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9389f079174e451d1e53b49ca87e33db">&#9670;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::process </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main class entry point. It will puplate the outgoing_buffer with message that should be sent as a response to the passed-in message. You can execute the entire algorithm simply by calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#a9389f079174e451d1e53b49ca87e33db">process()</a> with a <a class="el" href="structle_1_1ghs_1_1SrchPayload.html" title="Requests a search begin in the MST subtree rooted at the receiver, for the minimum weight outgoing ed...">SrchPayload</a> message properly constructed (but use <a class="el" href="classle_1_1ghs_1_1GhsState.html#a817fb9ac310ad6d8cd51bb5094fa7f3d">start_round()</a> for this), then feeding in all the response messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a></td><td>to process </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>into which to push the response messages </td></tr>
    <tr><td class="paramname">sz</td><td>the size_t that will be set to the number of messages added to outgoing_buffer on success, or left unset otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd>
<dd>
<a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> </dd></dl>

</div>
</div>
<a id="a99d3eb11d5455ae117d917555a429842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d3eb11d5455ae117d917555a429842">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the algorithm state, as though this object were just constructed (but preserving my_id)</p>
<p>Reset the algorithm status completely </p>

</div>
</div>
<a id="aea4d8fd7601b228107b8c91d087cca5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4d8fd7601b228107b8c91d087cca5c">&#9670;&nbsp;</a></span>set_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes (or adds) an edge to the outgoing edge list. If the edge you pass in does not exist, then it will be added. Edges are considered identical if and only if they are to-and-from the same nodes.</p>
<p>The edge must satisfy:</p><ul>
<li>To someone else (peer)</li>
<li>From us (root)</li>
<li>Not weight 0 or otherwise same weight as <a class="el" href="namespacele_1_1ghs.html#acc0f23a676c88aeca736df05ed044fc6">worst_edge()</a></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if successful </dd>
<dd>
Retcode SET_INVALID_EDGE if edge has root!=my_id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>an <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> </dd>
<dd>
<a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> </dd></dl>

</div>
</div>
<a id="a1fbf1bd3e39538b1bd36e0b5436c8f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbf1bd3e39538b1bd36e0b5436c8f96">&#9670;&nbsp;</a></span>set_edge_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_edge_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the internally stored <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to have a metric_t matching <code>m</code>.</p>
<p>Functionally equivalent to:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> desired;</div>
<div class="line">Edge e;</div>
<div class="line"><a class="code" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> to;</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a491d9729e0a7ec8ec63e12c261c63af6">get_edge</a>(to,e);</div>
<div class="line">e.metric_val = desired;</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge</a>(to,e);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">m</td><td>the metric_t to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a32752d80f78b09c368236e864de84e0d">has_edge()</a> </dd></dl>

</div>
</div>
<a id="a9060b49a13e52c70f195059c772037a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9060b49a13e52c70f195059c772037a5">&#9670;&nbsp;</a></span>set_edge_status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_edge_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the internally stored <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to have a status_t matching <code>status</code>.</p>
<p>Functionally equivalent to:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> desired;</div>
<div class="line">Edge e;</div>
<div class="line"><a class="code" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> to;</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a491d9729e0a7ec8ec63e12c261c63af6">get_edge</a>(to,e);</div>
<div class="line">e.status = desired;</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">set_edge</a>(to,e);</div>
</div><!-- fragment --><p><b>Warning</b> if you really need to remove an edge from the MST construction, perhaps because it is temporarily unavailable, you might be tempted to set the status to DELETED. I would recommend you not do this unless <a class="el" href="classle_1_1ghs_1_1GhsState.html#a30a22ed8e6d3e432da497631a99bd414">waiting_count()</a> and delayd_count() is zero, and you are confident that you will not soon receive <a class="el" href="structle_1_1ghs_1_1SrchPayload.html" title="Requests a search begin in the MST subtree rooted at the receiver, for the minimum weight outgoing ed...">SrchPayload</a> messages from other nodes over that link. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">status</td><td>the status_t to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a32752d80f78b09c368236e864de84e0d">has_edge()</a> </dd></dl>

</div>
</div>
<a id="ad468fa0b565af04eccebf400bf48d18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad468fa0b565af04eccebf400bf48d18a">&#9670;&nbsp;</a></span>set_leader_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_leader_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>leader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the leader of this node to the given agent_t </p><dl class="section return"><dt>Returns</dt><dd>Retcode OK. Never fails </dd></dl>

</div>
</div>
<a id="ab89293e324b9b4b7f1b4f7f1a276ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89293e324b9b4b7f1b4f7f1a276ebd8">&#9670;&nbsp;</a></span>set_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a> &amp;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the level of this node to the given level_t </p><dl class="section return"><dt>Returns</dt><dd>Retcode OK. Never fails </dd></dl>

</div>
</div>
<a id="a325badddc6fbbb2e1120cb939af2e806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325badddc6fbbb2e1120cb939af2e806">&#9670;&nbsp;</a></span>set_parent_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_parent_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the MST parent link (of which we have only one!). The edge to the parent must satisfy one of:</p><ul>
<li>get_edge_status(id,s) returns an MST edge</li>
<li>agent_t == <a class="el" href="classle_1_1ghs_1_1GhsState.html#a4f35fee46691587eb4d6f351b0e75ff8">get_id()</a></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd>
<dd>
Retcode PARENT_UNRECOGNIZED if <code>!has_edge(id)</code> </dd>
<dd>
Retcode PARENT_REQ_MST if we do not have an MST link to that <code>id</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status()</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> </dd></dl>

</div>
</div>
<a id="a614b988eb7e1e715fd9ac8c3335c321b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614b988eb7e1e715fd9ac8c3335c321b">&#9670;&nbsp;</a></span>set_response_prompt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_response_prompt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1InPartPayload.html">InPartPayload</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caches the message that triggered a delay in response, so that we can look it up later to check if our level matches the requester's level. We do that check whenever our level changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who sent the message </td></tr>
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">InPartPayload</a></td><td>the payload of the message that we cannot respond to yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a25d346bd8cc18b48b7bc02396aba5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d346bd8cc18b48b7bc02396aba5387">&#9670;&nbsp;</a></span>set_response_required()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_response_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>response_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the flag that denotes we have received an IN_PART message, but are not yet ready to respond. This occurs when the senders level is higher than ours, because we may just not yet know that we are actually part of their partition. We will know for sure when our level is == theirs, and we know the other agent will not respond if their level &lt; ours.</p>
<p>If you wish to "manually steer" the ghs algorithm using this function, then you should also use <a class="el" href="classle_1_1ghs_1_1GhsState.html#a614b988eb7e1e715fd9ac8c3335c321b">set_response_prompt()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting to send (true) or not waiting (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>
<dl class="section see"><dt>See also</dt><dd>respond_later() </dd>
<dd>
process_in_part() </dd></dl>

</div>
</div>
<a id="acdffbfd844f9725278968aedef953c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdffbfd844f9725278968aedef953c71">&#9670;&nbsp;</a></span>set_waiting_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::set_waiting_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>waiting_for</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the flag that denotes we have sent an IN_PART message to this agent, but have not yet received a response (true) or have received their response (false). <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting for (true) or not waiting for (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
Retcode NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
Retcode IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a817fb9ac310ad6d8cd51bb5094fa7f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817fb9ac310ad6d8cd51bb5094fa7f3d">&#9670;&nbsp;</a></span>start_round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::start_round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>ONLY IF</b> this node is the root of an MST (even an MST with only itself as a member) <b>THEN</b> this function will enqueue the first set of messages to send to all peers, and set up the internal state of the algorithm to be ready to process the responses.</p>
<p>In short it:</p><ul>
<li>checks to make sure we're not already in a search phase, exiting with error if we are.</li>
<li>resets the MWOE to a default value</li>
<li>creates a <a class="el" href="structle_1_1ghs_1_1SrchPayload.html" title="Requests a search begin in the MST subtree rooted at the receiver, for the minimum weight outgoing ed...">SrchPayload</a> and calls <a class="el" href="classle_1_1ghs_1_1GhsState.html#a3b67adf0443e2bd7994881a16a292afc">mst_broadcast()</a></li>
</ul>
<p>Calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#a817fb9ac310ad6d8cd51bb5094fa7f3d">start_round()</a> while in the middle of a round will essentially lose all state, such that incomign messages that are not a response to <em>these outgoing messages</em> will likely cause errors.</p>
<p>However, no edge statuses are changed, so executing start_round is safe if you already know of some MST links and have edited them in, or have somehow terminated a round and want to resume it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StaticQeueue</td><td>in which to enque outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>the number of messages enque'd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if successful </dd>
<dd>
Retcode SRCH_STILL_WAITING if <a class="el" href="classle_1_1ghs_1_1GhsState.html#a30a22ed8e6d3e432da497631a99bd414">waiting_count()</a> is not zero</dd></dl>
<p>Queue up the start of the round </p>

</div>
</div>
<a id="a4c221ee7a83dbd0ab71291f52143f393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c221ee7a83dbd0ab71291f52143f393">&#9670;&nbsp;</a></span>typecast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#aac347dba4047a0b57893ee8895e66acb">Retcode</a> GhsState::typecast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5">Msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html">Msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="structle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters edges by <code>msgtype</code>, and sends outgoing message along those that match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_t</td><td>the edge status along which to send messages. </td></tr>
    <tr><td class="paramname"><a class="el" href="structle_1_1ghs_1_1Msg.html#a370b06fc697eb0808ccb008188852cf5" title="Stores what type of Msg this is.">Msg::Type</a></td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1Msg_1_1Data.html" title="A union of all possible payloads.">Msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retcode OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">set_edge_status()</a> </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a68361919ac2145344adf1d4d92f3d4f4">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a30a22ed8e6d3e432da497631a99bd414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a22ed8e6d3e432da497631a99bd414">&#9670;&nbsp;</a></span>waiting_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t GhsState::waiting_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of agents to which we have already sent IN_PART messages, but from which we have not yet received ACK_PART or NACK_PART messages.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#acdffbfd844f9725278968aedef953c71">set_waiting_for()</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">InPartPayload</a> </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/hook/ws/cadre/dev/distributed-leader-election/include/ghs/<a class="el" href="ghs_8h_source.html">ghs.h</a></li>
<li>/home/hook/ws/cadre/dev/distributed-leader-election/include/ghs/<a class="el" href="ghs__impl_8hpp_source.html">ghs_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespacele_1_1ghs_html_a02e97afae479b0142591b5615f61d58e"><div class="ttname"><a href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">le::ghs::agent_t</a></div><div class="ttdeci">int agent_t</div><div class="ttdoc">problems for GhsState</div><div class="ttdef"><b>Definition:</b> agent.h:51</div></div>
<div class="ttc" id="anamespacele_1_1ghs_html_a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b"><div class="ttname"><a href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b">le::ghs::MST</a></div><div class="ttdeci">@ MST</div><div class="ttdoc">We have added this edge as an MST link.</div><div class="ttdef"><b>Definition:</b> edge.h:86</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_aea4d8fd7601b228107b8c91d087cca5c"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#aea4d8fd7601b228107b8c91d087cca5c">le::ghs::GhsState::set_edge</a></div><div class="ttdeci">Retcode set_edge(const Edge &amp;e)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:897</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a1fbf1bd3e39538b1bd36e0b5436c8f96"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a1fbf1bd3e39538b1bd36e0b5436c8f96">le::ghs::GhsState::set_edge_metric</a></div><div class="ttdeci">Retcode set_edge_metric(const agent_t &amp;to, const metric_t m)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:875</div></div>
<div class="ttc" id="anamespacele_1_1ghs_html_a2fae5fec7662f91a571573e574b2f7c9"><div class="ttname"><a href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">le::ghs::metric_t</a></div><div class="ttdeci">unsigned long metric_t</div><div class="ttdef"><b>Definition:</b> edge.h:63</div></div>
<div class="ttc" id="anamespacele_1_1ghs_html_a84d3095aaf4e4704c377dd7fe2195632"><div class="ttname"><a href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">le::ghs::status_t</a></div><div class="ttdeci">status_t</div><div class="ttdoc">A status enumeration, for the ghs edges.</div><div class="ttdef"><b>Definition:</b> edge.h:82</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a25d346bd8cc18b48b7bc02396aba5387"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a25d346bd8cc18b48b7bc02396aba5387">le::ghs::GhsState::set_response_required</a></div><div class="ttdeci">Retcode set_response_required(const agent_t &amp;who, const bool response_required)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:771</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a7429a609856ffa154ad57e06fd9ac718"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a7429a609856ffa154ad57e06fd9ac718">le::ghs::GhsState::is_response_required</a></div><div class="ttdeci">Retcode is_response_required(const agent_t &amp;who, bool &amp;response_required)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:782</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_af00a247c6505cff0a2c585da498278fc"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#af00a247c6505cff0a2c585da498278fc">le::ghs::GhsState::get_response_prompt</a></div><div class="ttdeci">Retcode get_response_prompt(const agent_t &amp;who, InPartPayload &amp;m)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:802</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a614b988eb7e1e715fd9ac8c3335c321b"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a614b988eb7e1e715fd9ac8c3335c321b">le::ghs::GhsState::set_response_prompt</a></div><div class="ttdeci">Retcode set_response_prompt(const agent_t &amp;who, const InPartPayload &amp;m)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:792</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_ab6cb3901a7cee8c9fad5e39aa5f310e8"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#ab6cb3901a7cee8c9fad5e39aa5f310e8">le::ghs::GhsState::get_edge_metric</a></div><div class="ttdeci">Retcode get_edge_metric(const agent_t &amp;to, metric_t &amp;m) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:864</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a08dfe0a489d1b84d87772c5db4382d8f"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a08dfe0a489d1b84d87772c5db4382d8f">le::ghs::GhsState::get_edge_status</a></div><div class="ttdeci">Retcode get_edge_status(const agent_t &amp;to, status_t &amp;out) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:841</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a9060b49a13e52c70f195059c772037a5"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a9060b49a13e52c70f195059c772037a5">le::ghs::GhsState::set_edge_status</a></div><div class="ttdeci">Retcode set_edge_status(const agent_t &amp;to, const status_t &amp;status)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:853</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a491d9729e0a7ec8ec63e12c261c63af6"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a491d9729e0a7ec8ec63e12c261c63af6">le::ghs::GhsState::get_edge</a></div><div class="ttdeci">Retcode get_edge(const agent_t &amp;to, Edge &amp;out) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:830</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
