<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHS: le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHS
   </div>
   <div id="projectbrief">Leader Election Based on GHS Minimum Spanning Tree</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacele.html">le</a></li><li class="navelem"><a class="el" href="namespacele_1_1ghs.html">ghs</a></li><li class="navelem"><a class="el" href="classle_1_1ghs_1_1GhsState.html">GhsState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classle_1_1ghs_1_1GhsState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b>The main state machine for the GHS algorithm</b>  
 <a href="classle_1_1ghs_1_1GhsState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ghs_8h_source.html">ghs.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a520911b68152e9bc23d5427c4df74a11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a520911b68152e9bc23d5427c4df74a11">GhsState</a> (<a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> my_id, <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> *edges, size_t num_edges)</td></tr>
<tr class="separator:a520911b68152e9bc23d5427c4df74a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cef04ee4afaca7bc95890d9cb24a4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a9cef04ee4afaca7bc95890d9cb24a4d3">start_round</a> (<a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;outgoing_msgs, size_t &amp;)</td></tr>
<tr class="separator:a9cef04ee4afaca7bc95890d9cb24a4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af004e992cbcf6282eb31bf5508748c66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#af004e992cbcf6282eb31bf5508748c66">process</a> (const <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a> &amp;msg, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;outgoing_buffer, size_t &amp;sz)</td></tr>
<tr class="separator:af004e992cbcf6282eb31bf5508748c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6f3f76c3e48e65e00e2887a9592d9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged</a> () const</td></tr>
<tr class="separator:acf6f3f76c3e48e65e00e2887a9592d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab8531afa092db6a5958a6987369bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a85ab8531afa092db6a5958a6987369bd">get_n_peers</a> () const</td></tr>
<tr class="separator:a85ab8531afa092db6a5958a6987369bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbb245eedce1aa71550c8225e07ff93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#abbbb245eedce1aa71550c8225e07ff93">get_edge</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;out) const</td></tr>
<tr class="separator:abbbb245eedce1aa71550c8225e07ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3ca84698fa7547b5fd145f312ed8f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a6e3ca84698fa7547b5fd145f312ed8f2">has_edge</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> to) const</td></tr>
<tr class="separator:a6e3ca84698fa7547b5fd145f312ed8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098787b2150c45fd0f39d7fd6e602d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a098787b2150c45fd0f39d7fd6e602d28">get_edge_status</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;out) const</td></tr>
<tr class="separator:a098787b2150c45fd0f39d7fd6e602d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f1ac1d24e0af0ed0e17a8791bea31c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a57f1ac1d24e0af0ed0e17a8791bea31c">get_edge_metric</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;to, <a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> &amp;m) const</td></tr>
<tr class="separator:a57f1ac1d24e0af0ed0e17a8791bea31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4358ebf67bd73f419f8d3d5cb443a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a8c4358ebf67bd73f419f8d3d5cb443a6">is_waiting_for</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, bool &amp;out_waiting_for)</td></tr>
<tr class="separator:a8c4358ebf67bd73f419f8d3d5cb443a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af319e652bb8b0a393ab086fabbf9df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#af319e652bb8b0a393ab086fabbf9df8d">is_response_required</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, bool &amp;response_required)</td></tr>
<tr class="separator:af319e652bb8b0a393ab086fabbf9df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806717468c401be62e03965ac559b9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a806717468c401be62e03965ac559b9f1">get_response_prompt</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;who, <a class="el" href="structle_1_1ghs_1_1msg_1_1InPartPayload.html">msg::InPartPayload</a> &amp;m)</td></tr>
<tr class="separator:a806717468c401be62e03965ac559b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f35fee46691587eb4d6f351b0e75ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a4f35fee46691587eb4d6f351b0e75ff8">get_id</a> () const</td></tr>
<tr class="separator:a4f35fee46691587eb4d6f351b0e75ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba914bec431efab91efc47c7f105057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#abba914bec431efab91efc47c7f105057">get_parent_id</a> () const</td></tr>
<tr class="separator:abba914bec431efab91efc47c7f105057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789e0899e91d62a6d2cc11a66833d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a6789e0899e91d62a6d2cc11a66833d89">get_leader_id</a> () const</td></tr>
<tr class="separator:a6789e0899e91d62a6d2cc11a66833d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34be79320fdff6ee68650d582fc7756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ac34be79320fdff6ee68650d582fc7756">get_level</a> () const</td></tr>
<tr class="separator:ac34be79320fdff6ee68650d582fc7756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a22ed8e6d3e432da497631a99bd414"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a30a22ed8e6d3e432da497631a99bd414">waiting_count</a> () const</td></tr>
<tr class="separator:a30a22ed8e6d3e432da497631a99bd414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb95007147563e87a19aaca69531ce2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#aabb95007147563e87a19aaca69531ce2">delayed_count</a> () const</td></tr>
<tr class="separator:aabb95007147563e87a19aaca69531ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692b1f38078dd2f3a39b36f61fd5ef54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a692b1f38078dd2f3a39b36f61fd5ef54">mwoe</a> () const</td></tr>
<tr class="separator:a692b1f38078dd2f3a39b36f61fd5ef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387387580922af5f00e0d075134e9fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a387387580922af5f00e0d075134e9fe7">checked_index_of</a> (const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;, size_t &amp;) const</td></tr>
<tr class="separator:a387387580922af5f00e0d075134e9fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4638bc4f7266858e82b190b719ac5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#ad4638bc4f7266858e82b190b719ac5f2">mst_broadcast</a> (const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:ad4638bc4f7266858e82b190b719ac5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674025154b2f85a42ee2f8c746e96c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#a674025154b2f85a42ee2f8c746e96c08">mst_convergecast</a> (const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:a674025154b2f85a42ee2f8c746e96c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51329952e47fa0c30d78c674e2921ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classle_1_1ghs_1_1GhsState.html#aa51329952e47fa0c30d78c674e2921ca">typecast</a> (const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> status, const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>, const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;, <a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;buf, size_t &amp;) const</td></tr>
<tr class="separator:aa51329952e47fa0c30d78c674e2921ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt;<br />
class le::ghs::GhsState&lt; NUM_AGENTS, MSG_Q_SIZE &gt;</h3>

<p><b>The main state machine for the GHS algorithm</b> </p>
<p><a class="el" href="classle_1_1ghs_1_1GhsState.html" title="The main state machine for the GHS algorithm">GhsState</a> is the message-driven state machine that executes the GHS algorithm. It receives incoming messages from a communication layer, and returns the next batch of messages to send. When completed, <a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged()</a> will return true.</p>
<p>You are responsible for describing the communication graph by calling, probably, set_edge() and then starting the algorithm by calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#a9cef04ee4afaca7bc95890d9cb24a4d3">start_round()</a> on at least one node (the root), but most likely just call it on all nodes, which will generate the first set of messages to send.</p>
<p>Then, as response messages come in from other nodes, just feed them into <a class="el" href="classle_1_1ghs_1_1GhsState.html#af004e992cbcf6282eb31bf5508748c66">process()</a> until <a class="el" href="classle_1_1ghs_1_1GhsState.html#acf6f3f76c3e48e65e00e2887a9592d9f">is_converged()</a> is true. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a520911b68152e9bc23d5427c4df74a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520911b68152e9bc23d5427c4df74a11">&#9670;&nbsp;</a></span>GhsState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GhsState::GhsState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td>
          <td class="paramname"><em>my_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the state of the GHS algorithm for this particular node.</p>
<p>Requires a agent_t to represent the node id, which will be used in all incoming and outgoing mesasages (unique among all agents).</p>
<p>Requires a list of <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">le::ghs::Edge</a> structures that represent the communication links to other agents that will not be modified during execution.</p>
<p>The edge list may contain any number of edges (up to NUM_AGENTS). This class will ignore (not copy in) any edge that:</p>
<ul>
<li>Is not rooted on this node (<a class="el" href="structle_1_1ghs_1_1Edge.html#a2aadbbe58e3ae3143c7e228dc5aae2a8" title="The root is the &quot;from&quot; side of the edge.">Edge.root</a> != my_id)</li>
<li>Is directed to this node (<a class="el" href="structle_1_1ghs_1_1Edge.html#ac5af30e895dd30418def560ffbcd83a9" title="The peer is the &quot;to&quot; side of the edge.">Edge.peer</a> == my_id)</li>
<li>Has either peer or root set to <a class="el" href="namespacele_1_1ghs.html#acfb2b2dad2c01489b30346645357c7ca">le::ghs::NO_AGENT</a></li>
<li>Has metric_val set to that of <a class="el" href="namespacele_1_1ghs.html#acc0f23a676c88aeca736df05ed044fc6">worst_edge()</a></li>
<li>otherwise does not pass <a class="el" href="namespacele_1_1ghs.html#a237657b7624a7b418a15aa942c0a324d">is_valid()</a></li>
</ul>
<p>The following conditions will produce undefined behavior:</p>
<ul>
<li>Passing in two or more edges with the same peer and root</li>
</ul>
<p>After the construction, you can verify the number of copied edges with <a class="el" href="classle_1_1ghs_1_1GhsState.html#a85ab8531afa092db6a5958a6987369bd">get_n_peers()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_id</td><td>of type agent_t that tells the class which edges to consider </td></tr>
    <tr><td class="paramname">edges</td><td>a set of <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">le::ghs::Edge</a> structures, which are filtered and stored internally to determine message destinations. </td></tr>
    <tr><td class="paramname">num_edges</td><td>the length of the edge set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a387387580922af5f00e0d075134e9fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387387580922af5f00e0d075134e9fe7">&#9670;&nbsp;</a></span>checked_index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::checked_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A much-called function that returns the index of the given agent. The index corresponds to a number 0 to N-1 for N agents, such that all data about that agent can be stored in consecutive memory. This is not a hash function! It simply searches as an O(n) operation, the memory for the matching ID.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if the index was found </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if not </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if you requsted index to this agent </dd></dl>

</div>
</div>
<a id="aabb95007147563e87a19aaca69531ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb95007147563e87a19aaca69531ce2">&#9670;&nbsp;</a></span>delayed_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t GhsState::delayed_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of agents from which we have received an IN_PART message that we have not responded to.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_response_required() </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1msg_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">msg::InPartPayload</a> </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<a id="abbbb245eedce1aa71550c8225e07ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbb245eedce1aa71550c8225e07ff93">&#9670;&nbsp;</a></span>get_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populates the given edge with any stored edge that connects this agent to another agent. If we are unaware of that agent or do not have an edge, return error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>an agent_t to look up </td></tr>
    <tr><td class="paramname">out</td><td>and <a class="el" href="structle_1_1ghs_1_1Edge.html" title="A struct to hold all the communication edge information.">Edge</a> to populate as an out parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if edge cannot be found </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if successful </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1GhsState.html#a6e3ca84698fa7547b5fd145f312ed8f2">has_edge()</a> </dd></dl>

</div>
</div>
<a id="a57f1ac1d24e0af0ed0e17a8791bea31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f1ac1d24e0af0ed0e17a8791bea31c">&#9670;&nbsp;</a></span>get_edge_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::get_edge_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a2fae5fec7662f91a571573e574b2f7c9">metric_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the edge metric to the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">m</td><td>the metric_t that is populated if the function is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a098787b2150c45fd0f39d7fd6e602d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098787b2150c45fd0f39d7fd6e602d28">&#9670;&nbsp;</a></span>get_edge_status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::get_edge_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the edge status to the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>agent_t identifier </td></tr>
    <tr><td class="paramname">out</td><td>the status_t that is populated if the function is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a4f35fee46691587eb4d6f351b0e75ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f35fee46691587eb4d6f351b0e75ff8">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever was set (or initialized) as the agent_t for this state machine</p>
<p>Never fails to return</p>
<dl class="section return"><dt>Returns</dt><dd>agent_t for this class's id. <br  />
 </dd></dl>

</div>
</div>
<a id="a6789e0899e91d62a6d2cc11a66833d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789e0899e91d62a6d2cc11a66833d89">&#9670;&nbsp;</a></span>get_leader_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_leader_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe my leader is </p>

</div>
</div>
<a id="ac34be79320fdff6ee68650d582fc7756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34be79320fdff6ee68650d582fc7756">&#9670;&nbsp;</a></span>get_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#af19481d9be5a0c234ce05633a702a710">level_t</a> GhsState::get_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe this partition's level is </p>

</div>
</div>
<a id="a85ab8531afa092db6a5958a6987369bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ab8531afa092db6a5958a6987369bd">&#9670;&nbsp;</a></span>get_n_peers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classle_1_1ghs_1_1GhsState.html">le::ghs::GhsState</a>&lt; NUM_AGENTS, MSG_Q_SIZE &gt;::get_n_peers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of peers, which is a counter that is incremented every time you add_edge_to(id) (or variant), with a new id. </p>

</div>
</div>
<a id="abba914bec431efab91efc47c7f105057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba914bec431efab91efc47c7f105057">&#9670;&nbsp;</a></span>get_parent_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> GhsState::get_parent_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whatever I believe my parent is </p><dl class="section return"><dt>Returns</dt><dd>agent_t corresponding to the parent id. Could be self! </dd></dl>

</div>
</div>
<a id="a806717468c401be62e03965ac559b9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806717468c401be62e03965ac559b9f1">&#9670;&nbsp;</a></span>get_response_prompt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::get_response_prompt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structle_1_1ghs_1_1msg_1_1InPartPayload.html">msg::InPartPayload</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the message that triggered a delay in response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who sent the message </td></tr>
    <tr><td class="paramname">InPartPayload</td><td>the outgoing payload of the message that we cannot respond to yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if successful </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if we cannot find the given agent id </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id </dd></dl>

</div>
</div>
<a id="a6e3ca84698fa7547b5fd145f312ed8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3ca84698fa7547b5fd145f312ed8f2">&#9670;&nbsp;</a></span>has_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GhsState::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a>&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any of the following will work:</p>
<div class="fragment"><div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#abbbb245eedce1aa71550c8225e07ff93">get_edge</a>()</div>
<div class="line">set_edge_status()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a098787b2150c45fd0f39d7fd6e602d28">get_edge_status</a>()</div>
<div class="line">set_edge_metric()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a57f1ac1d24e0af0ed0e17a8791bea31c">get_edge_metric</a>()</div>
<div class="line">set_response_required()</div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#af319e652bb8b0a393ab086fabbf9df8d">is_response_required</a>()</div>
<div class="line">set_response_prompt() </div>
<div class="line"><a class="code" href="classle_1_1ghs_1_1GhsState.html#a806717468c401be62e03965ac559b9f1">get_response_prompt</a>()</div>
</div><!-- fragment --><p>If it returns false, all of them will fail by returning something other than <a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK. </p>

</div>
</div>
<a id="acf6f3f76c3e48e65e00e2887a9592d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6f3f76c3e48e65e00e2887a9592d9f">&#9670;&nbsp;</a></span>is_converged()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GhsState::is_converged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the state machine believes that a global MST has converged </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="af319e652bb8b0a393ab086fabbf9df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af319e652bb8b0a393ab086fabbf9df8d">&#9670;&nbsp;</a></span>is_response_required()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::is_response_required </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>response_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the response-delayed status for the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting to send (true) or not waiting (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful and <code>waiting_for</code> is a valid return </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if we cannot find the given agent id and <code>waiting_for</code> may have any value </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id and <code>waiting_for</code> may have any value </dd></dl>

</div>
</div>
<a id="a8c4358ebf67bd73f419f8d3d5cb443a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4358ebf67bd73f419f8d3d5cb443a6">&#9670;&nbsp;</a></span>is_waiting_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::is_waiting_for </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a02e97afae479b0142591b5615f61d58e">agent_t</a> &amp;&#160;</td>
          <td class="paramname"><em>who</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>out_waiting_for</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the waiting status for the given agent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent_t</td><td>who </td></tr>
    <tr><td class="paramname">bool</td><td>waiting for response (true) or not waiting for response (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OK if successful and <code>waiting_for</code> is a valid return </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> NO_SUCH_PEER if we cannot find the given agent id and <code>waiting_for</code> may have any value </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> IMPL_REQ_PEER_MY_ID if edge has peer==my_id and <code>waiting_for</code> may have any value </dd></dl>

</div>
</div>
<a id="ad4638bc4f7266858e82b190b719ac5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4638bc4f7266858e82b190b719ac5f2">&#9670;&nbsp;</a></span>mst_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::mst_broadcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends messages to MST child links only. There are very good reasons for using MST links even for non-ghs messages, so this is public.</p>
<p>For example, this ensures each node only receives one copy, even if it is a "bottleneck" leading towards many agents.</p>
<p>Functionally equivalent to:</p>
<div class="fragment"><div class="line">Mst m;</div>
<div class="line">StaticQueue buf;</div>
<div class="line"><span class="keywordtype">size_t</span> qsz;</div>
<div class="line"><span class="keywordflow">return</span> mst_typecast(<a class="code" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b">MST</a>, m.type, m.data, buf, qsz);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg::Type</td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_edge_status() </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a674025154b2f85a42ee2f8c746e96c08">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a674025154b2f85a42ee2f8c746e96c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674025154b2f85a42ee2f8c746e96c08">&#9670;&nbsp;</a></span>mst_convergecast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::mst_convergecast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The opposite of mst_broadcast, will send messages "UP" the MST to the root.</p>
<p>useful for conducting "reduce" operations on an MST, assuming it is combined with a useful data reduction strategy.</p>
<p>In GHS, the reduction strategy is to compare <a class="el" href="structle_1_1ghs_1_1msg_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">msg::SrchRetPayload</a> from all incoming MST links, and pass the minimum weight edge up to the parent.</p>
<p>Is actually implemented with a search across all edges for one of type MST and with peer matching our parent id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg::Type</td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_edge_status() </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a674025154b2f85a42ee2f8c746e96c08">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a692b1f38078dd2f3a39b36f61fd5ef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b1f38078dd2f3a39b36f61fd5ef54">&#9670;&nbsp;</a></span>mwoe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle_1_1ghs_1_1Edge.html">Edge</a> GhsState::mwoe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current minimum weight outgoing edge (MWOE).</p>
<p>This is the edge we would add to our partition if you forced us to chose from our minimum spanning tree rooted at ourself. To find the global MWOE, these are passed UP the MST using <a class="el" href="classle_1_1ghs_1_1GhsState.html#a674025154b2f85a42ee2f8c746e96c08">mst_convergecast()</a>, with a <a class="el" href="structle_1_1ghs_1_1msg_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">msg::SrchRetPayload</a>. At each node, the <a class="el" href="structle_1_1ghs_1_1msg_1_1SrchRetPayload.html" title="Returns an edge that represents the minimum weight outgoing edge.">msg::SrchRetPayload</a> is compared to our <a class="el" href="classle_1_1ghs_1_1GhsState.html#a692b1f38078dd2f3a39b36f61fd5ef54">mwoe()</a> to determine the actual best edge all the way up to the root of the MST for this partition. After that, a <a class="el" href="structle_1_1ghs_1_1msg_1_1JoinUsPayload.html" title="Msgs to merge /absorb two partitions across a given edge.">msg::JoinUsPayload</a> is sent back from the root using <a class="el" href="classle_1_1ghs_1_1GhsState.html#ad4638bc4f7266858e82b190b719ac5f2">mst_broadcast()</a> to trigger the process of adding that edge to the MST</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_response_required() </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1msg_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">msg::InPartPayload</a> </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<a id="af004e992cbcf6282eb31bf5508748c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af004e992cbcf6282eb31bf5508748c66">&#9670;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::process </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main class entry point. It will puplate the outgoing_buffer with message that should be sent as a response to the passed-in message. You can execute the entire algorithm simply by calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#af004e992cbcf6282eb31bf5508748c66">process()</a> with a <a class="el" href="structle_1_1ghs_1_1msg_1_1SrchPayload.html" title="Requests a search begin in the MST subtree rooted at the receiver, for the minimum weight outgoing ed...">msg::SrchPayload</a> message properly constructed (but use <a class="el" href="classle_1_1ghs_1_1GhsState.html#a9cef04ee4afaca7bc95890d9cb24a4d3">start_round()</a> for this), then feeding in all the response messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a></td><td>to process </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>into which to push the response messages </td></tr>
    <tr><td class="paramname">sz</td><td>the size_t that will be set to the number of messages added to outgoing_buffer on success, or left unset otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> </dd></dl>

</div>
</div>
<a id="a9cef04ee4afaca7bc95890d9cb24a4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cef04ee4afaca7bc95890d9cb24a4d3">&#9670;&nbsp;</a></span>start_round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::start_round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>outgoing_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>ONLY IF</b> this node is the root of an MST (even an MST with only itself as a member) <b>THEN</b> this function will enqueue the first set of messages to send to all peers, and set up the internal state of the algorithm to be ready to process the responses.</p>
<p>In short it:</p><ul>
<li>checks to make sure we're not already in a search phase, exiting with error if we are.</li>
<li>resets the MWOE to a default value</li>
<li>creates a <a class="el" href="structle_1_1ghs_1_1msg_1_1SrchPayload.html" title="Requests a search begin in the MST subtree rooted at the receiver, for the minimum weight outgoing ed...">msg::SrchPayload</a> and calls <a class="el" href="classle_1_1ghs_1_1GhsState.html#ad4638bc4f7266858e82b190b719ac5f2">mst_broadcast()</a></li>
</ul>
<p>Calling <a class="el" href="classle_1_1ghs_1_1GhsState.html#a9cef04ee4afaca7bc95890d9cb24a4d3">start_round()</a> while in the middle of a round will essentially lose all state, such that incomign messages that are not a response to <em>these outgoing messages</em> will likely cause errors.</p>
<p>However, no edge statuses are changed, so executing start_round is safe if you already know of some MST links and have edited them in, or have somehow terminated a round and want to resume it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StaticQeueue</td><td>in which to enque outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>the number of messages enque'd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if successful </dd>
<dd>
<a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> SRCH_STILL_WAITING if <a class="el" href="classle_1_1ghs_1_1GhsState.html#a30a22ed8e6d3e432da497631a99bd414">waiting_count()</a> is not zero</dd></dl>
<p>Queue up the start of the round </p>

</div>
</div>
<a id="aa51329952e47fa0c30d78c674e2921ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51329952e47fa0c30d78c674e2921ca">&#9670;&nbsp;</a></span>typecast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> GhsState::typecast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632">status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="msg_8h.html#af67e0b6b29c9670865d7d13fc1c9d699">msg::Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseque_1_1StaticQueue.html">StaticQueue</a>&lt; <a class="el" href="classle_1_1ghs_1_1Msg.html">Msg</a>, MSG_Q_SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters edges by <code>msgtype</code>, and sends outgoing message along those that match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_t</td><td>the edge status along which to send messages. </td></tr>
    <tr><td class="paramname">msg::Type</td><td>denoting what type of message to send </td></tr>
    <tr><td class="paramname"><a class="el" href="unionle_1_1ghs_1_1msg_1_1Data.html">msg::Data</a></td><td>denoting what message data to broadcast </td></tr>
    <tr><td class="paramname">StaticQueue</td><td>in which to queue the outgoing messages </td></tr>
    <tr><td class="paramname">size_t</td><td>denoting how many messages were enqueued <em>only</em> if OK is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacele.html#a8527120ca75deda9dc60249a6d3c9929">le::Errno</a> OK if everything went well </dd>
<dd>
CAST_INVALID_EDGE if we found an edge without us as root </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_edge_status() </dd>
<dd>
mst_typecast() </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1GhsState.html#a674025154b2f85a42ee2f8c746e96c08">mst_convergecast()</a> </dd></dl>

</div>
</div>
<a id="a30a22ed8e6d3e432da497631a99bd414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a22ed8e6d3e432da497631a99bd414">&#9670;&nbsp;</a></span>waiting_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_AGENTS, std::size_t MSG_Q_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t GhsState::waiting_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of agents to which we have already sent IN_PART messages, but from which we have not yet received ACK_PART or NACK_PART messages.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>
<dl class="section see"><dt>See also</dt><dd>set_waiting_for() </dd>
<dd>
<a class="el" href="structle_1_1ghs_1_1msg_1_1InPartPayload.html" title="Asks &quot;Are you in my partition&quot;.">msg::InPartPayload</a> </dd>
<dd>
<a class="el" href="classle_1_1ghs_1_1Msg.html" title="An aggregate type containing all the data to exchange with to/from information.">Msg</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ghs/<a class="el" href="ghs_8h_source.html">ghs.h</a></li>
<li>include/ghs/<a class="el" href="ghs__impl_8hpp_source.html">ghs_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a57f1ac1d24e0af0ed0e17a8791bea31c"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a57f1ac1d24e0af0ed0e17a8791bea31c">le::ghs::GhsState::get_edge_metric</a></div><div class="ttdeci">le::Errno get_edge_metric(const agent_t &amp;to, metric_t &amp;m) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:892</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a806717468c401be62e03965ac559b9f1"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a806717468c401be62e03965ac559b9f1">le::ghs::GhsState::get_response_prompt</a></div><div class="ttdeci">le::Errno get_response_prompt(const agent_t &amp;who, msg::InPartPayload &amp;m)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:825</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_abbbb245eedce1aa71550c8225e07ff93"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#abbbb245eedce1aa71550c8225e07ff93">le::ghs::GhsState::get_edge</a></div><div class="ttdeci">le::Errno get_edge(const agent_t &amp;to, Edge &amp;out) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:855</div></div>
<div class="ttc" id="anamespacele_1_1ghs_html_a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b"><div class="ttname"><a href="namespacele_1_1ghs.html#a84d3095aaf4e4704c377dd7fe2195632ab65fe7ca80710f08c9838dc3677c462b">le::ghs::MST</a></div><div class="ttdeci">@ MST</div><div class="ttdoc">We have added this edge as an MST link.</div><div class="ttdef"><b>Definition:</b> edge.h:86</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_a098787b2150c45fd0f39d7fd6e602d28"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#a098787b2150c45fd0f39d7fd6e602d28">le::ghs::GhsState::get_edge_status</a></div><div class="ttdeci">le::Errno get_edge_status(const agent_t &amp;to, status_t &amp;out) const</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:867</div></div>
<div class="ttc" id="aclassle_1_1ghs_1_1GhsState_html_af319e652bb8b0a393ab086fabbf9df8d"><div class="ttname"><a href="classle_1_1ghs_1_1GhsState.html#af319e652bb8b0a393ab086fabbf9df8d">le::ghs::GhsState::is_response_required</a></div><div class="ttdeci">le::Errno is_response_required(const agent_t &amp;who, bool &amp;response_required)</div><div class="ttdef"><b>Definition:</b> ghs_impl.hpp:803</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
